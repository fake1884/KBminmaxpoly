ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
data_modelAR_estAR_bekannt_X.mat.trafo=matrix(rep(rep(NA, nobs), nobs), nrow=nobs)
data_modelAR_estAR_bekannt_X_mat_trafo=matrix(rep(rep(NA, nobs), nobs), nrow=nobs)
for(i in 1:ntest)
y = data_AR_test[,i]
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
data_modelAR_estAR_bekannt_beta[,i]=fit.1$coeff
data_modelAR_estAR_bekannt_sigma[i]=summary(fit.1)$sigma
}
R=Upsilon_fun(phi.true, nobs)[[1]]
inv.trafo.R=sqrt_inv_mat(R)[[1]]
X.trafo= inv.trafo.R %*% X
X.mat.trafo=t(X.trafo) %*% X.trafo
data_modelAR_estAR_bekannt_X_mat_trafo=solve(X.mat.trafo)
data_modelAR_estAR_bekannt_X_mat_trafo
data_modelAR_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
data_modelAR_estAR_X_trafo_inv=rep(list(matrix(rep(rep(NA, nobs), nobs), nrow=nobs)), ntest)
for(i in 1:ntest)
{
# Parameter schätzen
y=data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
data_modelAR_estAR_beta[,i]=fit.1$coeff
data_modelAR_estAR_sigma[i]=summary(fit.1)$sigma
# keine Ahnung, warum man das so berechnen muss
aux.1 = exp(summary(fit.1)$modelStruct[[1]][1])
phi = (aux.1 - 1) / (aux.1 + 1)
# X.inv.trafo in Abhängigkeit von phi bestimmen
R=Upsilon_fun(phi, nobs)[[1]]
inv.trafo.R=sqrt_inv_mat(R)[[1]]
X.trafo= inv.trafo.R %*% X
X.mat.trafo=t(X.trafo) %*% X.trafo
data_modelAR_estAR_X_trafo_inv[[i]]=solve(X.mat.trafo)
}
support_data_AR <- list(ntest, grad, nobs, beta.true, x, X, sigma.true, phi.true,
alpha, ngrid, X.mat, X.mat.inv, a, b)
names(support_data_AR) <- paste(c("ntest", "grad", "nobs", "beta.true", "x", "X", "sigma.true", "phi.true",
"alpha", "ngrid", "X.mat", "X.mat.inv", "a", "b"), sep = "")
devtools::use_data(data_AR_test, overwrite = T)
devtools::use_data(data_AR_true, overwrite = T)
devtools::use_data(support_data_AR, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_sigma, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_X_mat_trafo, overwrite = T)
devtools::use_data(data_modelAR_estAR_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_sigma, overwrite = T)
devtools::use_data(data_modelAR_estAR_X_trafo_inv, overwrite = T)
data_modelAR_estAR_bekannt_X_mat_trafo
data_modelAR_estAR_X_trafo_inv
data_modelAR_estAR_bekannt_X_mat_trafo
Make.data.AR.pruef()
Make.data.R.pruef()
Make.data.R()
ntest=100
set.seed(100)
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=0.007545373
phi.true=0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
k=1
I.tilde=I_tilde(k, grad)[[1]]
V=I.tilde %*% X.mat.inv %*% t(I.tilde)
beta.2=I.tilde %*% beta.true
data_AR_pruef_true = x^(grad-k) %*% beta.2
data_AR_pruef_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_pruef_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_pruef_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_pruef_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_pruef_estAR_bekannt_sigma[i]=fit.1[[3]]
}
devtools::load_all(".")
i
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
devtools::load_all(".")
fit.1 = ar.1(grad, y, phi.true)
devtools::load_all(".")
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_pruef_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_pruef_estAR_bekannt_sigma[i]=fit.1[[3]]
Make.data.AR.pruef()
ntest=100
set.seed(100)
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=0.007545373
phi.true=0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
k=1
I.tilde=I_tilde(k, grad)[[1]]
V=I.tilde %*% X.mat.inv %*% t(I.tilde)
beta.2=I.tilde %*% beta.true
data_AR_pruef_true = x^(grad-k) %*% beta.2
data_AR_pruef_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_pruef_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_pruef_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_pruef_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_pruef_estAR_bekannt_sigma[i]=fit.1[[3]]
}
data_modelAR_pruef_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
data_AR_test[,i]=y
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5,correlation=corAR1())
data_modelAR_pruef_estAR_beta[,i]=fit.1$coeff
data_modelAR_pruef_estAR_sigma[i]=summary(fit.1)$sigma
}
i
data_AR_test[,i]=y
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5,correlation=corAR1())
time
length(time)
length(time.1)
length(time.2)
length(time.3)
length(time.4)
length(time.5)
length(time.6)
grad
y
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5,correlation=corAR1())
fit.1=gls(y ~ time+time.2+time.3+time.4, correlation=corAR1())
y=data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
y
Make.data.AR.pruef()
# Anzahl an Testdurchl?ufen
ntest=100
# Reproduzierbarkeit gew?hrleisten
set.seed(100)
# feste Werte initialisieren
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=0.007545373
phi.true=0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
# Werte des Konfidenzbandes initialisieren
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
# Wir kennen den wahren Wert des Regressionsmodells schon
k=1
I.tilde=I_tilde(k, grad)[[1]]
V=I.tilde %*% X.mat.inv %*% t(I.tilde)
beta.2=I.tilde %*% beta.true
data_AR_pruef_true = x^(grad-k) %*% beta.2
######################################################
# matrix für das Testset
data_AR_pruef_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_pruef_test[,i]=X %*% beta.true+ t(e)
}
#############################################################
# schätzer für das Testset AR-bekannt
data_modelAR_pruef_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_pruef_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_pruef_estAR_bekannt_sigma[i]=fit.1[[3]]
}
#############################################################
# schätzer für das Testset AR
data_modelAR_pruef_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
y = data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
y
length(y)
y = data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3, correlation=corAR1())
y = data_AR_test[i,]
y
length(y)
fit.1 = gls(y ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
y = data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3, correlation=corAR1())
Make.data.AR()
# Anzahl an Testdurchl?ufen
ntest=100
# Reproduzierbarkeit gew?hrleisten
set.seed(100)
# feste Werte initialisieren
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=0.007545373
phi.true=0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
# Werte des Konfidenzbandes initialisieren
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
# Wir kennen den wahren Wert des Regressionsmodells schon
k=1
I.tilde=I_tilde(k, grad)[[1]]
V=I.tilde %*% X.mat.inv %*% t(I.tilde)
beta.2=I.tilde %*% beta.true
data_AR_pruef_true = x^(grad-k) %*% beta.2
######################################################
# matrix für das Testset
data_AR_pruef_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_pruef_test[,i]=X %*% beta.true+ t(e)
}
#############################################################
# schätzer für das Testset AR-bekannt
data_modelAR_pruef_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_pruef_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_pruef_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_pruef_estAR_bekannt_sigma[i]=fit.1[[3]]
}
#############################################################
# schätzer für das Testset AR
data_modelAR_pruef_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_pruef_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
y = data_AR_pruef_test[,i]
fit.1 = gls(y ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
data_modelAR_pruef_estAR_beta[,i]=fit.1$coeff
data_modelAR_pruef_estAR_sigma[i]=summary(fit.1)$sigma
Make.data.AR.pruef()
devtools::load_all(".")
devtools::load_all(".")
Make.data.AR.pruef()
data_modelAR_estAR_bekannt_X_mat_trafo
97.7
data_modelAR_estAR_X_trafo_inv[[1]]
devtools::load_all(".")
cov.R.AR=NA
system.time({cov.R.AR = Coverage.prob.fun("AR", "R")})
cov.minmax.AR=NA
system.time({cov.minmax.AR = Coverage.prob.fun("AR", "minmax", niter = 100)})
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 500)})
Convert.stem.data()
cov.R.AR.bekannt=NA
system.time({cov.R.AR.bekannt = Coverage.prob.fun("AR-bekannt", "R") })
cov.minmax.AR.bekannt=NA
system.time({cov.minmax.AR.bekannt = Coverage.prob.fun("AR-bekannt", "minmax", niter = 100)})
cov.poly.fast.AR.bekannt=NA
system.time({cov.poly.fast.AR.bekannt=Coverage.prob.fun("AR-bekannt", "minmax-poly-fast",
niter = 1000, ngridpoly = 500)})
devtools::load_all(".")
nobs.10=length(Y.10)
time.10.raw=c(0:(nobs.10-1))
time.10=time.10.raw/max(time.10.raw)
pdf("man/0-Latex/graphics/Stammzellen-10kPa/10kPa-data.pdf", width = 10, height = 8)
par(mar=c(5.1,5.1,4.1,2.1))
plot(time.10, Y.10, type="l", xlab="relative Zeit", ylab="relatives Wachstum",
cex=2, lwd=3, cex.axis=2, cex.lab=2)
dev.off()
nobs.30=length(Y.30)
time.30.raw=c(0:(nobs.30-1))
time.30=time.30.raw/max(time.30.raw)
pdf("man/0-Latex/graphics/Stammzellen-30kPa/30kPa-data.pdf",  width = 10, height = 8)
par(mar=c(5.1,5.1,4.1,2.1))
plot(time.30, Y.30, type="l", xlab="relative Zeit", ylab="relatives Wachstum",
cex=2, lwd=3, cex.axis=2, cex.lab=2)
dev.off()
Plot.estimation.methods(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-method.pdf")
Plot.estimation.methods(Y.30, 5, "man/0-Latex/graphics/Stammzellen-30kPa/30kPa-method.pdf")
devtools::load_all(".")
Plot.estimation.methods(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-method.pdf")
nobs = length(data.set)
time=0:(nobs-1)/(nobs-1)
data.set="Y.10"
degree=5
nobs = length(data.set)
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
Y.gls <- gls(data.set ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
data.set=Y.10
nobs = length(data.set)
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
Y.gls <- gls(data.set ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
beta=Y.gls$coefficients
sigma=Y.gls$sigma
aux.1 = exp(summary(Y.gls)$modelStruct[[1]][1])
phi = (aux.1 - 1) / (aux.1 + 1)
phi
X=matrix(data=NA,nrow=nobs,ncol=(degree+1))
for(j in 1:nobs){
for(i in 1:(degree+1)){X[j,i]=time[j]^(i-1)}
}
R=Upsilon_fun(phi, nobs)[[1]]
inv.trafo.R=sqrt_inv_mat(R)[[1]]
X.trafo= inv.trafo.R %*% X
X.mat.trafo=t(X.trafo) %*% X.trafo
inv.X=solve(X.mat.trafo)
inv.X
degree
alpha=0.05
niter=1000
par.KB.R <- KB.R(alpha, data.set, degree, inv.X)
par.KB.R <- KB.R(alpha, data.set, 7, inv.X)
par.KB.R <- KB.R(alpha, data.set, 6, inv.X)
par.KB.R <- KB.R(alpha, data.set, 5, inv.X)
par.KB.R <- KB.R(alpha, data.set, 4, inv.X)
inv.X
X.mat=t(X) %*% X
inv.X=solve(X.mat)
inv.X
devtools::load_all(".")
Plot.estimation.methods(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-method.pdf")
X.mat=t(X) %*% X
inv.X=solve(X.mat)
Plot.estimation.methods(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-method.pdf")
data.set=Y.10
degree=5
nobs = length(data.set)
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
Y.gls <- gls(data.set ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
beta=Y.gls$coefficients
sigma=Y.gls$sigma
aux.1 = exp(summary(Y.gls)$modelStruct[[1]][1])
phi = (aux.1 - 1) / (aux.1 + 1)
X=matrix(data=NA,nrow=nobs,ncol=(degree+1))
for(j in 1:nobs){
for(i in 1:(degree+1)){X[j,i]=time[j]^(i-1)}
}
X.mat=t(X) %*% X
inv.X=solve(X.mat)
alpha=0.05
niter=1000
par.KB.R <- KB.R(alpha, data.set, degree, inv.X)
nobs
grad
grad=degree
grad
inv.X
q <-qf(1-alpha,grad+1, nobs-grad-1)
factor <- sqrt((grad+1)*q)
q
factor
erg=list(factor)
par.KB.R <- KB.R(alpha, nobs, degree, inv.X)
par.KB.minmax <- KB.minmax(alpha, data.set, degree, niter, inv.X, a=0, b=1)
par.KB.minmax <- KB.minmax(alpha, data.set, nobs, niter, inv.X, a=0, b=1)
par.KB.minmax <- KB.minmax(alpha, nobs, degree, niter, inv.X, a=0, b=1)
par.KB.poly <- KB.poly.fast(alpha, length(data.set), degree, niter, inv.X, a=0, b=1,
ngridpoly = length(data.set))
devtools::load_all(".")
Plot.estimation.methods(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-method.pdf")
Plot.estimation.methods(Y.30, 5, "man/0-Latex/graphics/Stammzellen-30kPa/30kPa-method.pdf")
length(data.set)
length(Y.10)
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 500)})
cov.R.minmax=NA
system.time({cov.R.minmax=Coverage.prob.fun("R", "minmax", niter = 1000)})
devtools::load_all(".")
Plot.estimation.methods(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-method.pdf")
Plot.estimation.methods(Y.30, 5, "man/0-Latex/graphics/Stammzellen-30kPa/30kPa-method.pdf")
Plot.degrees(Y.10, 5, "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-poly.pdf")
Plot.degrees(Y.30, 5, "man/0-Latex/graphics/Stammzellen-30kPa/30kPa-poly.pdf")
Plot.poly.KB(Y.10, c(4,5,6), "man/0-Latex/graphics/Stammzellen-10kPa/10kPa-poly-KB")
Plot.poly.KB(Y.30, c(4,5,6), "man/0-Latex/graphics/Stammzellen-30kPa/30kPa-poly-KB")
