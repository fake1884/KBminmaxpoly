library(KBminmaxpoly)
devtools::load_all(".")
mat_fun(1,1,matrix(c(1)), diag(2))
mat_fun(1,1,matrix(c(1,1)), diag(2))
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
devtools::load_all(".")
library(KBminmaxpoly)
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
mat_fun(1, 1, t(matrix(c(1,1))), t(diag(2)))
mat_fun(1, 1, t(matrix(c(1,1))), t(matrix(c(1,1)))
)
mat_fun(1, 1, t(matrix(c(1,1))), t(matrix(c(1,1))))
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
mat_fun(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
g_fun_cpp(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
g_fun_cpp(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
g_fun_cpp(1, 1, t(matrix(c(1,1))), diag(2))
devtools::load_all(".")
g_fun_cpp(1, 1, t(matrix(c(1,1))), diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
g_fun_cpp(1, 1, t(matrix(c(1,1))), diag(2))
devtools::load_all(".")
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 100, ngridpoly = 100)})
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 200, ngridpoly = 100)})
devtools::load_all(".")
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly", niter = 100)})
devtools::load_all(".")
system.time({cov=Coverage.prob.fun("R", "minmax-poly", niter = 100)})
library(KBminmaxpoly)
devtools::load_all(".")
mvrnormArma(2, c(1,1), diag(2))
mvtnorm::rmvnorm(n=1,mean=c(1,1),sigma=diag(2))
?rmvnorm
mvrnormArma(1, c(1,1), diag(2))
devtools::load_all(".")
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1, ngridpoly = 100)})
devtools::load_all(".")
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1, ngridpoly = 100)})
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 100, ngridpoly = 100)})
mvrnormArma(1, c(0,0), dig(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
?arma::randn
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 500, ngridpoly = 100)})
Coverage.prob.fun("AR-bekannt", "minmax-poly", niter = 100)
devtools::load_all(".")
system.time({cov=Coverage.prob.fun("R", "minmax-poly", niter = 100)})
Coverage.prob.fun("AR", "minmax-poly", niter = 100)
par.bsp.R
par.bsp.R=KB.poly(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b)
niter=100
par.bsp.R=KB.poly(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b)
par.bsp.R
devtools::load_all(".")
par.bsp.R=KB.poly(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b)
par.bsp.R
mvrnormArma(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvtnorm::rmvnorm(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
mvrnormArma(1, c(0,0), diag(2))
Coverage.prob.fun("AR", "minmax-poly", niter = 100)
devtools::load_all(".")
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
ngridpoly=100
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
par.bsp.R
devtools::load_all(".")
par.bsp.R=KB.poly(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b)
par.bsp.R
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.poly(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter, support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b)
par.bsp.R
par.bsp.R=KB.minmax(support_data_AR$alpha, data_AR_test[,i], support_data_AR$grad , niter,
support_data_AR$X.mat.inv, support_data_AR$a, support_data_AR$b)
i=1
par.bsp.R=KB.minmax(support_data_AR$alpha, data_AR_test[,i], support_data_AR$grad , niter,
support_data_AR$X.mat.inv, support_data_AR$a, support_data_AR$b)
par.bsp.R
Coverage.prob.fun("AR", "minmax-poly-fast", niter = 100, ngridpoly = 100)
Coverage.prob.fun("AR-bekannt", "minmax-poly-fast", niter = 100, ngridpoly = 100)
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
par.bsp.AR=KB.minmax(support_data_AR$alpha, data_AR_test[,i], support_data_AR$grad , niter,
support_data_AR$X.mat.inv, support_data_AR$a, support_data_AR$b)
par.bsp.AR
ntest=100
set.seed(100)
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=1
phi.true=0.1
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
data_AR_true = (X %*% beta.true)
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
data_AR_test
data_AR_true
data_AR_test[,i]
i
plot(x = time, y = data_AR_pruef_test[i])
length(time)
length(data_AR_test[i])
length(data_AR_test[,i])
plot(x = time, y = data_AR_test[,i])
plot(x = time, y = data_AR_test[,1])
plot(x = time, y = data_AR_test[,2])
plot(x = time, y = data_AR_test[,3])
devtools::load_all(".")
Make.data.AR()
library(nlme)
Make.data.AR()
devtools::load_all(".")
plot(x = time, y = data_AR_test[,3])
plot(x = time, y = data_AR_test[,1])
plot(x = time, y = data_AR_test[,2])
plot(x = time, y = data_AR_test[,3])
plot(x = time, y = data_AR_test[,4])
plot(x = time, y = data_AR_test[,5])
?curve
?poly
par.bsp.R=KB.poly(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b)
par.bsp.R
par.bsp.AR=KB.minmax(support_data_AR$alpha, data_AR_test[,i], support_data_AR$grad , niter,
support_data_AR$X.mat.inv, support_data_AR$a, support_data_AR$b)
par.bsp.AR
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
ngridpoly=100
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
Coverage.prob.fun("AR-bekannt", "minmax-poly-fast", niter = 100, ngridpoly = 100)
devtools::load_all(".")
Make.data.AR()
devtools::load_all(".")
Coverage.prob.fun("AR-bekannt", "minmax-poly-fast", niter = 100, ngridpoly = 100)
Coverage.prob.fun("AR", "minmax-poly-fast", niter = 100, ngridpoly = 100)
Coverage.prob.fun("AR", "R")
Coverage.prob.fun("AR", "minmax", niter = 100)
Coverage.prob.fun("AR", "minmax-poly", niter = 100)
n
p
n=10
p=1
v=n-p-1
sqrt(rchisq(n=1,df=v)/v)
library(KBminmaxpoly)
devtools::load_all(".")
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 5, ngridpoly = 100)})
devtools::load_all(".")
cov=NA
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 5, ngridpoly = 100)})
library(KBminmaxpoly)
devtools::load_all(".")
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 5, ngridpoly = 100)})
devtools::load_all(".")
system.time({cov=Coverage.prob.fun("R", "minmax-poly-fast", niter = 5, ngridpoly = 100)})
data=Y.10
if(data=="Y.10"){data.set=Y.10}else if(data=="Y.30"){data.set=Y.30}
data="Y.10"
if(data=="Y.10"){data.set=Y.10}else if(data=="Y.30"){data.set=Y.30}
alpha=0.05
niter=250
nobs=length(data.set)
ngridpoly=nobs
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
time.6=time^6
alpha=0.05
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
grad=5
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
I.tilde=I_tilde(k, grad)[[1]]
V=I.tilde %*% X.mat.inv %*% t(I.tilde)
k=1
I.tilde=I_tilde(k, grad)[[1]]
V=I.tilde %*% X.mat.inv %*% t(I.tilde)
Y.gls.5 <- gls(data.set ~ time+time.2+time.3+time.4+time.5, correlation=corAR1())
Y.gls.6 <- gls(data.set ~ time+time.2+time.3+time.4+time.5+time.6, correlation=corAR1())
Y.gls.5
Y.gls.5$sigma
devtools::load_all(".")
library(KBminmaxpoly)
library(KBminmaxpoly)
devtools::load_all(".")
test_fun(diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
g_fun_cpp(1,1, c(0,0), 1, dig(2))
g_fun_cpp(1,1, c(0,0), 1, diag(2))
g_fun_cpp(1,1, matrix(c(0,0)), 1, diag(2))
library(KBminmaxpoly)
devtools::load_all(".")
rep_fun(1,1)
rep_fun(1,10)
rep_fun(0,10)
rep(0,10)
length(rep_fun(0,10))
length(rep(0,10))
library(KBminmaxpoly)
devtools::load_all(".")
Make.data.AR()
Make.data.AR()
Make.data.AR()
ntest=100
set.seed(100)
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=0.007545373
phi.true=0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
data_AR_true = (X %*% beta.true)
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_estAR_bekannt_sigma[i]=fit.1[[3]]
}
data_modelAR_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
data_AR_test[,i]=y
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5,correlation=corAR1())
data_modelAR_estAR_beta[,i]=fit.1$coeff
data_modelAR_estAR_sigma[i]=summary(fit.1)$sigma
}
support_data_AR <- list(ntest, grad, nobs, beta.true, x, X, sigma.true, phi.true,
alpha, ngrid, X.mat, X.mat.inv, a, b)
names(support_data_AR) <- paste(c("ntest", "grad", "nobs", "beta.true", "x", "X", "sigma.true", "phi.true",
"alpha", "ngrid", "X.mat", "X.mat.inv", "a", "b"), sep = "")
devtools::use_data(data_AR_test, overwrite = T)
devtools::use_data(data_AR_true, overwrite = T)
devtools::use_data(data_modelAR_estAR_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_sigma, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_sigma, overwrite = T)
devtools::use_data(support_data_AR, overwrite = T)
Make.data.AR = function(){
# Anzahl an Testdurchl?ufen
ntest=100
# Reproduzierbarkeit gew?hrleisten
set.seed(100)
# feste Werte initialisieren
grad=5
nobs=50
beta.true=c(10,5,-4,7,3,-4)
sigma.true=0.007545373
phi.true=0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
# Wir kennen den wahren Wert des Regressionsmodells schon
data_AR_true = (X %*% beta.true)
# Werte des Konfidenzbandes initialisieren
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
######################################################
# matrix für das Testset
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
#############################################################
# schätzer für das Testset AR-bekannt
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_estAR_bekannt_sigma[i]=fit.1[[3]]
}
#############################################################
# schätzer für das Testset AR
data_modelAR_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter schätzen
data_AR_test[,i]=y
fit.1=gls(y ~ time+time.2+time.3+time.4+time.5,correlation=corAR1())
data_modelAR_estAR_beta[,i]=fit.1$coeff
data_modelAR_estAR_sigma[i]=summary(fit.1)$sigma
}
################################################################
# Daten speichern
support_data_AR <- list(ntest, grad, nobs, beta.true, x, X, sigma.true, phi.true,
alpha, ngrid, X.mat, X.mat.inv, a, b)
names(support_data_AR) <- paste(c("ntest", "grad", "nobs", "beta.true", "x", "X", "sigma.true", "phi.true",
"alpha", "ngrid", "X.mat", "X.mat.inv", "a", "b"), sep = "")
devtools::use_data(data_AR_test, overwrite = T)
devtools::use_data(data_AR_true, overwrite = T)
devtools::use_data(data_modelAR_estAR_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_sigma, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_sigma, overwrite = T)
devtools::use_data(support_data_AR, overwrite = T)
}
devtools::load_all(".")
devtools::load_all(".")
Make.data.AR()
devtools::load_all(".")
library("KBminmaxpoly", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.3")
library("mvtnorm", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.3")
library("nlme", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.3")
library("quadprog", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.3")
seed.1=100
set.seed(seed.1)
grad=3
nobs=50
x.raw=c(1:nobs)
x=x.raw/max(x.raw)
X=numeric()
for(i in 1:(grad+1)){X=matrix(c(X,x^(i-1)),ncol=i)}
beta=c(10,5,-4,7)
sigma=1
I.mat = diag(length(x.raw))
e=rmvnorm(1,mean=rep(0,length(x.raw)), sigma=sigma*I.mat)
y.raw=X %*% beta + t(e)
plot(x.raw,y.raw, xlab="Zeit", ylab="Wachstum", pch=1, cex=2, lwd=3, cex.axis=2, cex.lab=2)
max(y.raw)
y=y.raw/max(y.raw)
grad.1=3
fit.1=OLS(grad.1, y, length(y))
inv.X.1=fit.1[[1]]
beta.1=fit.1[[2]]
sigma.1=fit.1[[3]]
beta.1
sigma.1
y.raw
max(y.raw)
beta.traf=beta.1 * max(y.raw)
sigma.traf=sigma.1 * max(y.raw)
beta.traf
sigma.traf
