# Konfidenzband bestimmen
plot.KB.R=plot.KB(support_data_AR$nobs, support_data_AR$grad, support_data_AR$X.mat.inv,
data_modelAR_estAR_beta[,i], data_modelAR_estAR_sigma[i], par.bsp.R[[1]],
support_data_AR$ngrid)
# liegt das wahre modell in dem Konfidenzband?
if(Test.function(support_data_AR$nobs, plot.KB.R[[2]], plot.KB.R[[3]], model.type)==F){
nerfolg=nerfolg-1
}
}
model.type="AR"
for(i in 1:support_data_AR$ntest)
{
# Konfidenzband bestimmen
plot.KB.R=plot.KB(support_data_AR$nobs, support_data_AR$grad, support_data_AR$X.mat.inv,
data_modelAR_estAR_beta[,i], data_modelAR_estAR_sigma[i], par.bsp.R[[1]],
support_data_AR$ngrid)
# liegt das wahre modell in dem Konfidenzband?
if(Test.function(support_data_AR$nobs, plot.KB.R[[2]], plot.KB.R[[3]], model.type)==F){
nerfolg=nerfolg-1
}
}
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 10, ngridpoly = 10)})
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
devtools::load_all(".")
Coverage.prob.fun("AR", "R")
data_AR_test
devtools::load_all(".")
Coverage.prob.fun("AR", "R")
par.bsp.R
par.bsp.R=KB.minmax(support_data_AR$alpha, data_AR_test[,i], support_data_AR$grad , niter,
support_data_AR$X.mat.inv, support_data_AR$a, support_data_AR$b)
par.bsp.R=KB.R(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
support_data_AR$X.mat.inv)
par.bsp.R
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
devtools::load_all(".")
Coverage.prob.fun("AR", "minmax", niter = 100)
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/man/Beispiel-R.R')
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/man/Beispiel-R.R')
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/man/Beispiel-AR.R')
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/man/Beispiel-AR.R')
devtools::load_all(".")
Make.data.AR()
devtools::load_all(".")
Make.data.AR()
ntest=1000
set.seed(100)
grad = 3
nobs = 200
beta.true = c(10,5,-4,7)
sigma.true=0.5 #0.007545373
phi.true=0.001 #0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/(max(x.raw)/20)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
data_AR_true = (X %*% beta.true)
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter sch채tzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_estAR_bekannt_sigma[i]=fit.1[[3]]
}
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter sch채tzen
Y.gls.1 <- gls(data_AR_test[,i]~time+time.2+time.3, correlation=corAR1())
data_modelAR_estAR_bekannt_beta[,i]=Y.gls.1$coefficients
data_modelAR_estAR_bekannt_sigma[i]=Y.gls.1$sigma
}
data_AR_test[,i]
Y.gls.1 <- gls(data_AR_test[,i]~time+time.2+time.3, correlation=corAR1())
time
Y.gls.1 <- gls(data_AR_test[,i] ~ time+time.2+time.3, correlation=corAR1())
y = data_AR_test[,i]
Y.gls.1 <- gls(y ~ time+time.2+time.3, correlation=corAR1())
y
data_modelAR_estAR_bekannt_beta[,i]=Y.gls.1$coefficients
data_modelAR_estAR_bekannt_sigma[i]=Y.gls.1$sigma
data_modelAR_estAR_bekannt_sigma
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/R/make-test-data-AR.R')
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
devtools::load_all(".")
data_modelAR_estAR_sigma
ngridpoly=100
niter=1000
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
Coverage.prob.fun("AR", "R")
data_modelAR_estAR_sigma
data_modelAR_estAR_beta
data_modelAR_estAR_beta[,i]
i=1
data_modelAR_estAR_beta[,i]
data_modelAR_estAR_beta[,i] * (max(x.raw)/20)
x.raw=c(0:(nobs-1))
nobs = 200
x.raw=c(0:(nobs-1))
data_modelAR_estAR_beta[,i] * (max(x.raw)/20)
data_modelAR_estAR_beta[,i] * max(data_AR_true)
max(data_AR_true)
data_modelAR_estAR_beta[,i]
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
devtools::load_all(".")
Make.data.AR()
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/R/make-test-data-AR.R')
devtools::load_all(".")
Make.data.AR()
devtools::load_all(".")
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
ngridpoly=100
niter=1000
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
Coverage.prob.fun("AR", "R")
Coverage.prob.fun("AR", "minmax", niter = 100)
ntest=1000
set.seed(100)
grad = 3
nobs = 200
beta.true = c(10,5,-4,7)
sigma.true=0.5 #0.007545373
phi.true=0.001 #0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
X.mat.inv
devtools::load_all(".")
source('~/Dokumente/R/07-Bachelorarbeit-Konfidenzbaender/KBminmaxpoly/R/make-test-data-AR.R')
Make.data.AR()
devtools::load_all(".")
Make.data.AR()
devtools::load_all(".")
Make.data.AR()
ntest=1000
set.seed(100)
grad = 3
nobs = 200
beta.true = c(10,5,-4,7)
sigma.true=0.5 #0.007545373
phi.true=0.001 #0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
data_AR_true = (X %*% beta.true)
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter sch채tzen
y = data_AR_test[,i]
fit.1 = ar.1(grad, y, phi.true)
data_modelAR_estAR_bekannt_beta[,i]=fit.1[[2]]
data_modelAR_estAR_bekannt_sigma[i]=fit.1[[3]]
}
X.trafo.inv = fit.1[[5]]
data_modelAR_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
for(i in 1:ntest)
{
# Parameter sch채tzen
data_AR_test[,i]=y
# y ~ time+time.2+time.3+time.4+time.5
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
data_modelAR_estAR_beta[,i]=fit.1$coeff
data_modelAR_estAR_sigma[i]=summary(fit.1)$sigma
}
support_data_AR <- list(ntest, grad, nobs, beta.true, x, X, sigma.true, phi.true,
alpha, ngrid, X.mat, X.mat.inv, a, b, X.trafo.inv)
names(support_data_AR) <- paste(c("ntest", "grad", "nobs", "beta.true", "x", "X", "sigma.true", "phi.true",
"alpha", "ngrid", "X.mat", "X.mat.inv", "a", "b", "X.trafo.inv"), sep = "")
devtools::use_data(data_AR_test, overwrite = T)
devtools::use_data(data_AR_true, overwrite = T)
devtools::use_data(data_modelAR_estAR_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_sigma, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_beta, overwrite = T)
devtools::use_data(data_modelAR_estAR_bekannt_sigma, overwrite = T)
devtools::use_data(support_data_AR, overwrite = T)
devtools::load_all(".")
niter=1000
ngridpoly=100
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.trafo.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
i=1
plot.KB.R=plot.KB(support_data_AR$nobs, support_data_AR$grad, support_data_AR$X.trafo.inv,
data_modelAR_estAR_beta[,i], data_modelAR_estAR_sigma[i], par.bsp.R[[1]],
support_data_AR$ngrid)
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
X.trafo.inv
support_data_AR$X.mat.inv
support_data_AR$X.trafo.inv
devtools::load_all(".")
Coverage.prob.fun("AR", "R")
Coverage.prob.fun("AR-bekannt", "R")
devtools::load_all(".")
Coverage.prob.fun("AR-bekannt", "minmax", niter = 1000)
par.bsp.AR=KB.minmax(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad , niter,
support_data_AR$X.trafo.inv, support_data_AR$a, support_data_AR$b)
par.bsp.AR
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.trafo.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.poly(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter, support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b)
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.R(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
support_data_AR$X.mat.inv)
par.bsp.R
ngridpoly=500
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
support_data_AR$nobs
support_data_AR$grad
support_data_AR$X.mat.inv
par.bsp.R
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
par.bsp.R
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
cov.R.R=NA
system.time({cov.R.R=Coverage.prob.fun("R", "R")})
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
ngridpoly=500
niter=1000
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
par.bsp.R
niter=5000
ngridpoly=1000
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
par.bsp.R
x_fun_cpp(0.1,2)
x_fun_cpp(0.1,5)
x_fun_cpp(0.3,5)
x_fun_cpp(0.5,5)
library(KBminmaxpoly)
library(KBminmaxpoly)
devtools::load_all(".")
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
library(KBminmaxpoly)
devtools::load_all(".")
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
library(KBminmaxpoly)
devtools::load_all(".")
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
par.bsp.R=KB.poly.fast(support_data_R$alpha, support_data_R$nobs, support_data_R$grad,
niter,support_data_R$X.mat.inv, support_data_R$a,
support_data_R$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.R(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
support_data_AR$X.trafo.inv)
par.bsp.R
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.trafo.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
Coverage.prob.fun("AR-bekannt", "R")
cov.poly.fast.AR.bekannt=NA
system.time({cov.poly.fast.AR.bekannt=Coverage.prob.fun("AR-bekannt", "minmax-poly-fast",
niter = 1000, ngridpoly = 500)})
Coverage.prob.fun("AR-bekannt", "minmax", niter = 1000)
Coverage.prob.fun("AR-bekannt", "minmax", niter = 1000)
par.bsp.AR=KB.minmax(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad , niter,
support_data_AR$X.trafo.inv, support_data_AR$a, support_data_AR$b)
niter=1000
par.bsp.AR=KB.minmax(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad , niter,
support_data_AR$X.trafo.inv, support_data_AR$a, support_data_AR$b)
par.bsp.AR
i=1
plot.KB.R=plot.KB(support_data_AR$nobs, support_data_AR$grad, support_data_AR$X.trafo.inv,
data_modelAR_estAR_bekannt_beta[,i], data_modelAR_estAR_bekannt_sigma[i],
par.bsp.R[[1]], support_data_AR$ngrid)
devtools::load_all(".")
Coverage.prob.fun("AR-bekannt", "minmax", niter = 1000)
cov.R.R=NA
system.time({cov.R.R=Coverage.prob.fun("R", "R")})
cov.R.minmax=NA
system.time({cov.R.minmax=Coverage.prob.fun("R", "minmax", niter = 1000)})
cov.R.poly.fast=NA
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
ngridpoly=1000
niter=1000
ngridpoly=100
par.bsp.R=KB.poly.fast(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
niter,support_data_AR$X.mat.inv, support_data_AR$a,
support_data_AR$b, ngridpoly)
par.bsp.R
par.bsp.R=KB.R(support_data_AR$alpha, support_data_AR$nobs, support_data_AR$grad,
support_data_AR$X.mat.inv)
par.bsp.R
devtools::load_all(".")
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
cov.R.AR=NA
system.time({cov.R.AR = Coverage.prob.fun("AR", "R")})
# last run niter=1000, ngridpoly=500, cov.minmax.AR= 1000, system.time=
cov.minmax.AR=NA
system.time({cov.minmax.AR = Coverage.prob.fun("AR", "minmax", niter = 100)})
# diese Funktion scheint mittlerweile nicht mehr zu funktionieren
# last run niter=, ngridpoly=, cov.poly.fast.AR= , system.time=
cov.poly.AR=NA
system.time({cov.poly.AR=Coverage.prob.fun("AR", "minmax-poly", niter = 100)})
# last run niter=1000, ngridpoly=500, cov.poly.fast.AR= 1000, system.time=9881.355
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
devtools::load_all(".")
library(nlme)
library(mvtnorm)
cov.R.AR=NA
system.time({cov.R.AR = Coverage.prob.fun("AR", "R")})
# last run niter=1000, ngridpoly=500, cov.minmax.AR= 1000, system.time=
cov.minmax.AR=NA
system.time({cov.minmax.AR = Coverage.prob.fun("AR", "minmax", niter = 100)})
# diese Funktion scheint mittlerweile nicht mehr zu funktionieren
# last run niter=, ngridpoly=, cov.poly.fast.AR= , system.time=
cov.poly.AR=NA
system.time({cov.poly.AR=Coverage.prob.fun("AR", "minmax-poly", niter = 100)})
# last run niter=1000, ngridpoly=500, cov.poly.fast.AR= 1000, system.time=9881.355
cov.poly.fast.AR=NA
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
nlme
devtools::use_package(nlme)
devtools::use_package("nlme")
devtools::load_all(".")
devtools::load_all(".")
system.time({cov.R.poly.fast=Coverage.prob.fun("R", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
system.time({cov.poly.fast.AR=Coverage.prob.fun("AR", "minmax-poly-fast", niter = 1000, ngridpoly = 100)})
package_version("nlme")
packageVersion("nlme")
packageVersion("mvtnorm")
packageVersion("quadprog")
ntest=1000
set.seed(100)
grad = 3
nobs = 200
beta.true = c(10,5,-4,7)
sigma.true=0.5 #0.007545373
phi.true=0.001 #0.8225374  # bestimmt die korrelation
x.raw=c(0:(nobs-1))
x=x.raw/max(x.raw)
X=matrix(data=NA,nrow=nobs,ncol=(grad+1))
for(j in 1:nobs){
for(i in 1:(grad+1)){X[j,i]=x[j]^(i-1)}
}
X.mat=t(X) %*% X
X.mat.inv=solve(X.mat)
Upsilon = Upsilon_fun(phi.true, nobs)[[1]]
Upsilon= Upsilon * sigma.true
data_AR_true = (X %*% beta.true)
alpha=0.05
niter=100
ngrid=nobs
a=0 # diese Werte definieren A
b=1
time=0:(nobs-1)/(nobs-1)
time.2=time^2
time.3=time^3
time.4=time^4
time.5=time^5
alpha=0.05
ngrid=nobs
data_AR_test=matrix(rep(rep(NA, ntest), nobs), nrow=nobs)
for(i in 1:ntest)
{
# wahre Werte erzeugen
e=mvtnorm::rmvnorm(1,mean=rep(0,length(x.raw)),Upsilon)
data_AR_test[,i]=X %*% beta.true+ t(e)
}
data_modelAR_estAR_bekannt_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_bekannt_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
data_modelAR_estAR_beta=matrix(rep(rep(NA, ntest), grad+1), nrow=grad+1)
data_modelAR_estAR_sigma=matrix(rep(rep(NA, ntest), 1), nrow=1)
data_modelAR_estAR_phi=matrix(rep(rep(NA, ntest), 1), nrow=1)
i=1
data_AR_test[,i]=y
y=data_AR_test[,i]
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
devtools::load_all(".")
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
library(nlme)
detach("package:nlme", unload=TRUE)
devtools::load_all(".")
packageVersion("nlme")
devtools::load_all(".")
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
packageVersion("Rcpp")
devtools::load_all(".")
devtools::load_all(".")
fit.1=gls(y ~ time+time.2+time.3,correlation=corAR1())
library(nlme)
packageVersion("quadprog")
packageVersion("mvtnorm")
detach("package:nlme", unload=TRUE)
devtools::load_all(".")
detach("package:RcppArmadillo", unload=TRUE)
devtools::load_all(".")
library("Rcpp", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.3")
detach("package:Rcpp", unload=TRUE)
devtools::load_all(".")
library("nlme", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.3")
detach("package:nlme", unload=TRUE)
devtools::load_all(".")
detach("package:RcppArmadillo", unload=TRUE)
devtools::load_all(".")
